---
title: 位图索引
date: 2019-11-16 23:18:30
categories: DB基础
tags: 
- 位图
- B+树
---



假设instructor文件有两个索引，分别建立在dept_name和salary上。考虑如下查询：“找出金融系中工资为$80000的所有教师。”我们写作

```SQL
select ID
from instructor
where dept_name = 'Finance' and salary = 80000;
```

处理这个查询可以有三种策略：

1.利用dept_name上的索引，找出属于金融系的所有记录。检查每条记录是否满足salary=
80000。

2.利用salary上的索引，找出所有工资等于$80000的记录。检查每条记录是否满足depl_name=
"Finance"。

3.利用dept_name上的索引找出指向属于金融系的记录的所有指针。同样，利用salary上的索引找出指向工资等于80000的记录的所有指针。计算这两个指针集合的交。交集中的那些指针指向金融系中工资等于$80000的记录。

上面三种策略中只有第三种利用了存在的多个索引的优势。然而，如果下面所有条件都成立，即使这种策略也可能是很糟糕的选择：

- 属于金融系的记录太多。
- 余额为$80000的记录太多。
- 金融系中工资为$80000的记录只有几个。

如果这些条件成立的话，为了得到一个很小的结果集，我们必须扫描大量指针。一种称为“位图索引”的索引结构在某些情况下可以加速第三种策略中使用的集合交的操作。

# 位图索引
位图索引是一种为多码上的简单查询设计的特殊索引，尽管每个位图索引都是建立在单个码上的。

为了使用位图索引，关系中的记录必须按顺序编号，比如说从0开始。对于给定的一个n值，必须能很简单地检索到编号为n的记录。如果记录是大小固定的，而且位于文件的连续块上，则实现这一点就更容易了。然后，该记录号就可以很简单地转化为一个块编号和一个指出块内记录的记录号。
考虑一个关系r，它有一个属性A只能取很少的一些数值（例如，2~20）。例如，关系instructor_
info可能有一个属性gender，它只能取m（男）和f（女）值。另一个例子是属性income_level，此处收入分成5级：L1：$0～9999，L2：$10000～19999， L3：$20000～39999，14：$40000～74999，L5：
$75000～∞。在这里，原始数据可以取很多数值，但是数据分析者将这些数值划分成少数几个区间以简化数据分析。

## 位图索引结构
位图（bitmap）就是位的一个简单数组。在其最简单的形式中，关系r的属性A上的位图索引（bitmap index）是由A能取的每个值建立的位图构成的。每个位图都有和关系中的记录数相等数目的位。如果编号为i的记录在属性A上的值为u，则值为u的位图中的第i个位设置为1，而该位图上的其他所有位设置为0。

在该例子中，对值m和f都分别有一个位图。如果号码为i的记录的gender值为m，则m的位图中的第i位设置为1，而m的位图中的其他位设置为0。类似地，f位图中等于1的位对应于属性gender的值为f的记录，而其他位都为0。下图表示了关系instructor_info上的位图索引的例子。



|  ID   | gender  | income_level |
|:-----:|:-------:|:------------:|
| 76766 |    m    |      L1      |
| 22222 |    f    |      L2      |
| 12121 |    f    |      L1      |
| 15151 |    m    |      L4      |
| 58583 |    f    |      L3      |

gender的位图
| 性别 | 位图  |
|:------:|:-------:|
| m    | 10010 |
| f    | 01101 |

income_level的位图
| 工资等级 | 位图  |
|:----------:|:-------:|
| L1       | 10100 |
| L2       | 01000 |
| L3       | 00001 |
| L4       | 00010 |
| L5       | 00000 |

**我们现在考虑什么时候使用位图索引是有利的**。用属性值为m（或者f）来检索所有记录，最简单的办法就是读取关系中的所有记录，再选择其中值为m（或者f）的记录。在这样的办法中，位图索引实际上并不能加快检索速度。尽管它可以让我们只读取某个特定性别的记录，但是很有可能文件的所有块都需要被读取到。

事实上，**位图索引主要在对多个码上的选择操作有用**。假设如前所述，除了gender上的位图索引之外，还创建了属性income_level上的位图索引。

现在考虑一个选择收入在$10000~$19999之间的女性的查询。这个查询可以表示成为


```SQL
select *
from r
where gender = 'f' and income level = 'L2';
```
为了计算这个选择，我们取属性gender值为f的位图和属性income level值为L2的位图，然后执行两个位图的交（intersection）操作（逻辑与）。换句话说，我们计算出了一个新的位图，如果前面两个位图的第i位值都为1，则这个新位图的第i位值为1；否则，为0。例子中，gender的位图=
f（01101）和income_level的位图=L2（01000）的交得到位图01000。

因为第一个属性可以取两个值，第二个属性可以取5个值，所以我们认为，平均10条记录中只有一条记录能满足两个属性上的组合条件。如果有更多的条件，则满足所有条件的记录在所有记录中所占的比例可能就很小了。这样，系统可通过在交操作以后的位图中找出值为1的所有位，然后检索相应的记录来计算出查询结果。如果满足条件的记录所占比例很大，则扫描整个关系将是代价更低的一种选择。

位图的另一个重要应用就是统计满足所给选择条件的元组数。这样的检索对于数据分析很重要。
例如，我们希望找到有多少女性的收入水平为L2，我们计算两个位图的交，然后统计交操作后得到的位图中值为1的位的数目。这样我们甚至可以在不需要访问关系的条件下从位图索引得到需要的结果。

和实际关系大小相比，位图索引通常比较小。典型的记录至少是几十或几百字节长，然而在位图中一位就可以代表一条记录。这样，单个位图占用的空间通常少于关系所占空间的1%。例如，如果一个给定关系的记录长度为100字节，那么单个位图所占空间将是整个关系所占空间的1%的1/8。如果关系的属性A可以取8个值，那么属性A上的位图索引将包含8个位图，这8个位图一起仅占用该关系大小的1%。
删除记录会在顺序排列的记录之间产生间隙，因为移动记录（或者记录号）来填充间隙需要极大的代价。为了识别被删除的记录，我们可以存储一个存在位图（existence bitmap），在该位图中如果第i位的值为0，表示记录i不存在，否则为1。

我们了解存在位图的必要性。记录的插入不应该影响到其他记录的顺序编号。因此，我们可以通过在文件的末尾添加记录或者替换被删除的记录来完成插入操作。

## 位图操作的高效实现
我们可以简单地用一个for循环来计算两个位图的交：第i个循环计算两个位图的第i位的与（and）。我们可以通过大多数计算机指令集支持的位模式and 指令来显著加快交操作运算速度。根据不同的计算机体系结构，一个字（word）通常有32或64位。位模式and指令以两个字作为输入，输出一个字，该字的每一个位是输入的两个字对应位的与（and）。值得重点注意的是，位模式and指令可以用一次运算得到32位或者64位的交。

如果一个关系有100万条记录，每个位图将包含100万个位，相当于128KB。假设字长是32位的，则为计算该例子中的两个位图的交，只需要31250条指令。因此，位图的交运算就相当快。

正如位图的交运算可用于计算两个条件的与（and），位图的并可用来计算两个条件的或（or）。位图并的过程和位图与的过程十分相似，不同之处在于，我们用位模式or 指令代替位模式and指令。

补码操作可用于计算对某个条件取反的断言，例如not（income_level=L1）。位图的补码可以用位图中每一位的补码来产生（1的补码是0，0的补码是1）。看起来，我们好像可以通过计算收入等级为L1的位图的补码来实现not（income_level=L1）。但是，如果一些记录已经删除了，那么仅仅计算位图的补码是不够的。与删除记录相对应的位在原位图中为0，但在补码中将为1，而实际上该记录已经不存在了。当属性值为空（null）的时候，也会出现同样的问题。例如，如果income_level的值为空，在原来的位图中，值L1对应的位的值为0，而在补码位图中为1。

为了确保对应于被删除记录的位在结果中设置为0，补码位图必须和存在位图进行交操作使得已删除记录对应的位为0。类似地，处理空值时，补码位图也必须和空值（null）的补码位图进行交操作。(处理诸如is unknown之类的断言会导致更多麻烦，这通常需要使用为一个位图来跟踪未知的操作结果。)

可以通过一个巧妙的技术，使计算位图中值为1的位的数目变得很快。可以维护一个具有256个项的数组，其中第i个项存储i的二进制表示中值为1的位的个数。开始时设置总计数值为0。我们取得位图中的每一个字节，将它作为数组的下标，然后将其中存储的值加到总计数值上。加操作的数目将是整个元组数的1/8，因此该计数过程是很有效的。一个大的数组（使用216=65536个项）用多个字节来做数组下标，将会得到更高的加速比，但是需要更大的存储开销。

## 位图和B+树
对于一些属性值经常出现，而另外一些属性值虽然也出现，但出现频率很小的关系，位图可以和一般的B’树索引组合起来使用。在B’树索引的叶结点中，对于每个值，我们通常保留以这个值为索引属性值的所有记录的列表。列表的每个元素可以是记录的标识符，至少有32位，而通常会更多。对于一个在许多记录中都出现的值，我们存储一个位图而不是记录的列表。

假设一个特殊的值.在1/16的关系记录中出现。令N为关系中的记录数目，并假设每条记录有一个64位的号来标识它。位图仅需要1位来表示每条记录，总共需要N位。相对而言，在值出现的地方，列表需要64位来表示每条记录，即总共64*N/16=4N位。因此，我们更倾向于使用位图来表示值v；的记录列表。在该例子（使用64位记录标识）中，如果少于1/64的记录具有相同的值，对于标识具有这种特殊值的记录而言，则更倾向于使用列表表示，因为它比位图表示使用更少的位。如果多于1/64的记录具有相同的值，则倾向于使用位图表示。

因此，对于经常出现的那些值，我们可以在B+树的叶结点中使用位图来作为一种压缩存储机制。


# 本文节选自：

**《Database System Concepts — 6e 》**